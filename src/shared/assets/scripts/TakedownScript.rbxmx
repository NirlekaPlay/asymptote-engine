<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<Meta name="ExplicitAutoJoints">true</Meta>
	<External>null</External>
	<External>nil</External>
	<Item class="Script" referent="RBXc4b8671352134a32914fe8278f5a739a">
		<Properties>
			<ProtectedString name="Source"><![CDATA[--!strict
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local PlayerStatusTypes = require(ReplicatedStorage.shared.player.PlayerStatusTypes)
local PlayerStatusRegistry = require(ServerScriptService.server.player.PlayerStatusRegistry)

local remote = require(ReplicatedStorage.shared.network.remotes.TypedRemotes).ClientboundSetPlayerModuleDisability

local prompt = script.Parent
local npcCharacter = prompt:FindFirstAncestorOfClass("Model")
local npcHumanoid = npcCharacter and npcCharacter:FindFirstChildOfClass("Humanoid")
local npcRoot = npcCharacter and npcCharacter:FindFirstChild("HumanoidRootPart") :: BasePart

local TAKEDOWN_ANIM_ID = 97587604203797
local MOVE_TIMEOUT = 1.5 -- Max seconds to wait for player to reach the spot

local animation = Instance.new("Animation")
animation.AnimationId = "rbxassetid://" .. TAKEDOWN_ANIM_ID
animation.Parent = script

local function isPlayerBehind(targetRoot: BasePart, playerRoot: BasePart): boolean
	local targetForward = targetRoot.CFrame.LookVector
	local directionToPlayer = (playerRoot.Position - targetRoot.Position).Unit
	local dot = targetForward:Dot(directionToPlayer)
	return math.deg(math.acos(dot)) > 80
end

prompt.Triggered:Connect(function(player)
	-- 1. Initial Safety Checks
	local plrChar = player.Character
	if not (plrChar and npcRoot and npcHumanoid and npcHumanoid.Health > 0) then return end
	
	local plrRoot = plrChar:FindFirstChild("HumanoidRootPart") :: BasePart
	local plrHumanoid = plrChar:FindFirstChildOfClass("Humanoid")
	if not (plrRoot and plrHumanoid and plrHumanoid.Health > 0) then return end

	if not isPlayerBehind(npcRoot, plrRoot) then return end

	-- Lock the interaction
	prompt.Enabled = false
	
	-- Store state for restoration
	local prevWalkSpeed = plrHumanoid.WalkSpeed
	local prevJumpPower = plrHumanoid.JumpPower
	local statusHolder = PlayerStatusRegistry.getPlayerStatusHolder(player)

	-- 2. Cleanup Function (The "Insurance Policy")
	local function restorePlayer()
		if plrHumanoid and plrHumanoid.Parent then
			plrHumanoid.WalkSpeed = prevWalkSpeed
			plrHumanoid.JumpPower = prevJumpPower
		end
		remote:FireClient(player, true)
		if statusHolder then
			statusHolder:removeStatus(PlayerStatusTypes.CRIMINAL_SUSPICIOUS)
		end
	end

	-- 3. Positioning Sequence
	statusHolder:addStatus(PlayerStatusTypes.CRIMINAL_SUSPICIOUS)
	remote:FireClient(player, false)

	local goalPos = (npcRoot.CFrame * CFrame.new(0, 0, 1.5)).Position
	plrHumanoid:MoveTo(goalPos)

	-- Wait for arrival with a hard timeout
	local startWait = os.clock()
	repeat
		task.wait() 
	until (plrRoot.Position - goalPos).Magnitude < 1 or (os.clock() - startWait) > MOVE_TIMEOUT or not npcRoot.Parent

	-- Check if everyone is still alive/exists after the walk
	if not (plrRoot.Parent and npcRoot.Parent and plrHumanoid.Health > 0) then
		restorePlayer()
		return
	end

	-- 4. Animation Sequence
	plrRoot.CFrame = CFrame.lookAt(plrRoot.Position, npcRoot.Position * Vector3.new(1, 0, 1) + Vector3.new(0, plrRoot.Position.Y, 0))
	plrHumanoid.WalkSpeed = 0
	plrHumanoid.JumpPower = 0

	local animator = plrHumanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", plrHumanoid)
	local track = animator:LoadAnimation(animation)
	track.Priority = Enum.AnimationPriority.Action4
	
	-- Failsafe for animation loading
	local loadTimeout = 0
	while track.Length <= 0 and loadTimeout < 1 do
		loadTimeout += task.wait()
	end

	-- Connect Events
	local snapConnection: RBXScriptConnection
	snapConnection = track:GetMarkerReachedSignal("AnimEvent_TakedownSnap"):Connect(function()
		if npcHumanoid then npcHumanoid.Health = 0 end
		snapConnection:Disconnect()
	end)

	track:Play()
	
	-- Wait for end or interruption
	track.Ended:Wait()
	
	-- Final Cleanup
	restorePlayer()
	
	-- Clean up script/prompt if NPC is dead
	task.defer(function()
		if not (npcHumanoid and npcHumanoid.Health <= 0) then
			prompt.Enabled = true -- Allow retry if it failed somehow
		end
	end)
end)]]></ProtectedString>
			<bool name="Disabled">true</bool>
			<Content name="LinkedSource"><null></null></Content>
			<token name="RunContext">0</token>
			<string name="ScriptGuid">{24b841af-b023-425c-8861-3cdade2a10c1}</string>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Name">TakedownScript</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
</roblox>